## 고급 타입

### 인터섹션 타입 (&)

- 두 타입의 공통 타입
- 어떤 타입과도 사용할 수 있음.

```ts
type Admin = {
    name : string;
    privileges : string[];
}

type Employee = {
    name : string;
    startDate : new Date();
}

type ElevatedEmployee = Admin & Employee;

const e1: ElevatedEmployee = {
    name : 'Max',
    privileges : ['create-server'],
    startDate : new Date();
}
```

```ts
type Combinable = string | number;
type Numeric = number | boolean;
type Universal = Combinable & Numeric; // number type
```

- interface 의 상속과 유사하다.

```ts
interface Admin = {
    name : string;
    privileges : string[];
}

interface Employee  {
    name : string;
    startDate : Date;
}

interface ElevatedEmployee extends  Employee, Admin{}
```

### 형 변환(typecasting) <>, as

- 타입스크립트가 직접 감지하지 못하는 특정타입의 값을 타입스크립트에 알려주는 역할을 함
- <>, as 둘 중 어떤 걸 사용해도 괜찮지만, 한 프로젝트에서 통일하게 쓰도록 할 것!

```ts
const userInputElement = <HTMLInputElement>(
  document.getElementById("user-input")!
); // 느낌표(!) : 느낌표 앞의 표현식을 null로 반환하지 않겠다고 타입스크립트에게 인식시키는 것!

const userInputElement2 = document.getElementById(
  "user-input"
) as HTMLInputElement;

userInputElement.value = "Hi, there";
```

### 인덱스 속성

- 객체가 지닐 수 있는 속성에 대해 보다 유연한 객체를 생성할 수 있게 해쥼.

ex) interface내에 어떠한 객체가 오든 해당 타입을 지정하고 싶은 경우(어떠한 property든 관계없이 해당 타입을 적용시키고 싶은 경우)

```ts
interface ErrorContainer {
  id: string; // 사전정의된 속성 추가도 가능함- 단, index  type과 동일한 type이어야 함.
  [prop: string]: string; // index type
}

const errorBag : ErrorContainer {
    email : 'Not a valid email',
    username :  'Must start with a capital character!'
}
```

- 위 interface는 문자열 타입인 id를 추가하여 생성하는 객체가 id 속성을 지니도록 하고, 원하는 만큼 다른 속성을 추가할 수 있다.

- 단, id는 반드시 string 타입이어야 함! (인덱스 타입의 value가 string으로 지정되어있기 때문)

- index type은 유연성을 제공하기에 사용하고자 하는 속성 이름과 필요한 속성의 개수를 미리 알 필요가 없음.
